# 组件
> 一个功能独立、可通信的封装元件。

是的，就是这么简单，也应该是这么简单。

三个基本条件：

> * 功能独立
> * 可通信
> * 封装性

## 功能独立
每个组件都应该是为了实现某种特定功能而存在的，而组件的功能需要是独立于环境（使用组件的环境/上下文），换句话说，

> 组件的功能与其上下文应该是无关（解耦）的。

A中使用X组件实现了M功能；B中使用X，同样也应该是实现M功能。

举两个栗子：
### 雨伞
* 下雨天，我们用雨伞遮雨，雨伞起到了遮雨功能；
* 夏天，我们会用雨伞遮太阳，雨伞起到了遮阳功能。

不管是遮雨还是遮阳，我们都可以将雨伞的功能抽象为遮挡。因此，我们可以认为雨伞是功能独立的。

P.S. 黄飞鸿手里的雨伞可能还不只是遮挡，还可以用来打人。。请忽略

### 手机
* 与别人打电话时，手机实现了通信功能；
* 用手机拍照时，手机实现了照相功能。

不同使用场景，手机实现了不同功能，这时候，我们不能认为手机是功能独立的。

请注意：功能独立和功能单一，是完全不同的概念。这里不细说……

## 可通信
人可能独立存在，却不能离开地球的生物而存在的。同样，

> 组件的功能是独立的，但是，组件不能是封闭的。

一个封闭的组件，是无法被使用的，也就没有存在的意义。组件需要与其他组件或环境进行交流，或数据交流，或操作交流，或……总之，组件应该是**可通信**的。

可通信包括：

* 数据可通信：环境可以为组件分配数据，组件可以将数据输出至环境；
* 操作可通信：环境可以通知组件，组件根据接收的通知确定完成的操作；组件也可以通知环境操作的完成情况，环境根据组件的完成情况确定下一步操作。
* 状态可通信：组件可自维护状态，也可以将状态与环境共享。
* 其他：除了上述的提及的，不同的组件设计，也可能有其他可通信的。

上述的这些可通信虽然描述的是组件与环境间通信，亦可以是组件与组件间的通信。总之：

> 组件所拥有的一切，都应该是可以被通信的；哪些是可通信的需要根据特定的设计需求而定。

## 封装性
当环境在使用组件时，对于外部（环境和其他组件，下同），首先我们希望：

> 组件的特性对于外部是无污染的。

即引入的组件，其功能和通信都不应该导致外部的某些特性受到影响甚至改变。

同时，环境在使用组件时，对组件是如何完成功能以及如何进行通信是不需要知晓的，环境只需要知道如何使用组件即可，对此，我们希望：

> 组件的功能以及通信的具体实现对于外部是透明的。

组件对外的一切，都应该通过通信来与外部交流，其内部实现仅对内部可见及可用，对外部应该是透明的。

鉴于上述的两个特点，我们认为：

> 组件是封装的

封装性在面向对象编程中体现的是最直接的，在这一点上，组件和类是一样的，它们都需要隐藏内部实现，提供接口或通信供外部使用。

# Web组件
对于Web来讲，Web组件实际上是UI组件。一个Web组件除了应该具有上述组件的所有特性外，还应该包括：

* UI：结构、颜色、字体大小、透明度等，在Web领域里，其实就是View层，即HTML+CSS。HTML负责组件结构、框架；CSS将这些结构和框架渲染，使其具有外观。

而功能及通信，就集成于JS中，由JS实现组件的功能，以及组件的对外通信。于是，从代码层上讲，一个Web组件包括：

> * HTML：结构及框架
> * CSS：样式
> * JS：控制器，包括功能及通信

而Web的封装性，可以说是比其他编程语言的组件更难。HTML不需要考虑封装性，而CSS和JS的封装，在传统的Web编程中，可以说这是做不到的。

CSS样式是**高**可复用的，这也同样引入了**高**污染，相同的样式规则，可以渲染不同组件。

JS的代码，也可以说跟CSS是一样的。差别只是传统做法里，会使用约定来避免污染，比如：“命名空间”或闭包、命名规范、目录结构等。虽然这在一定程度上可以做到隔离外部环境，但是，并不能从根本上消除，因为JS代码里难免会对页面上的元素做处理，而这种处理的代码，本质上就是一种污染，因为你很可能处理的元素在其他组件上同样存在。
